class chunkgen extends Component { //[I-S]LN=0;[I-E]
  public class object { //[I-S]LN=1;[I-E]
    public SpatialObject TerrCriate(float posx, float posy) { //[I-S]LN=2;[I-E]
      SpatialObject Obj = new SpatialObject("chuck "); //[I-S]LN=3;[I-E]
      Obj.setStatic(true); //[I-S]LN=4;[I-E]
      Obj.addComponent(new ModelRenderer()); //[I-S]LN=5;[I-E]
      Obj.addComponent(new TerreController()); //[I-S]LN=6;[I-E]
      Obj.setPosition(posx, 0, posy); //[I-S]LN=7;[I-E]
      Obj.removeComponent(new TerreController()); //[I-S]LN=8;[I-E]
      return Obj; //[I-S]LN=9;[I-E]
    } //[I-S]LN=10;[I-E]
  } //[I-S]LN=11;[I-E]
 //[I-S]LN=12;[I-E]
  @Hide public float waterlevel = .5f; //[I-S]LN=13;[I-E]
  @Hide public int chunks = 4, width = 16, seed; //[I-S]LN=14;[I-E]
  public float heightscale, valuelog; //[I-S]LN=15;[I-E]
  public MaterialFile TerrMate, WaterMate; //[I-S]LN=16;[I-E]
  @Hide public chunkgen.object object; //[I-S]LN=17;[I-E]
  public ObjectFile[] trees = new ObjectFile[1]; //[I-S]LN=18;[I-E]
  private Vector3 myposGlobal; //[I-S]LN=19;[I-E]
  private int lastChuckX = Integer.MIN_VALUE, lastChuckZ = Integer.MIN_VALUE; //[I-S]LN=20;[I-E]
  private int myposxs, myposzs; //[I-S]LN=21;[I-E]
  public HashMap<Long, SpatialObject> chunck = new HashMap<Long, SpatialObject>(); //[I-S]LN=22;[I-E]
  private float time = 0, timechunk = 0; //[I-S]LN=23;[I-E]
  private int gerax, geraz, startx, startz, endx, endz; //[I-S]LN=24;[I-E]
  private boolean gerado = false; //[I-S]LN=25;[I-E]
 //[I-S]LN=26;[I-E]
  @Override //[I-S]LN=27;[I-E]
  void start() { //[I-S]LN=28;[I-E]
    object = new chunkgen.object(); //[I-S]LN=29;[I-E]
    seed = Random.range(0, 500); //[I-S]LN=30;[I-E]
    spawobjT(); //[I-S]LN=31;[I-E]
    processotime(16 * 16); //[I-S]LN=32;[I-E]
  }  //[I-S]LN=33;[I-E]
 //[I-S]LN=34;[I-E]
  @Override //[I-S]LN=35;[I-E]
  void repeat() { //[I-S]LN=36;[I-E]
    posplayermy(); //[I-S]LN=37;[I-E]
    if ((timechunk += Math.bySecond()) > 2f) { //[I-S]LN=38;[I-E]
      spawobjT(); //[I-S]LN=39;[I-E]
      timechunk = 0; //[I-S]LN=40;[I-E]
    } //[I-S]LN=41;[I-E]
    processotime(4); //[I-S]LN=42;[I-E]
    removeChunck(); //[I-S]LN=43;[I-E]
  } //[I-S]LN=44;[I-E]
 //[I-S]LN=45;[I-E]
  private void posplayermy() { //[I-S]LN=46;[I-E]
    myposGlobal = myObject.getGlobalPosition(); //[I-S]LN=47;[I-E]
    myposxs = (int) Math.Floor(myposGlobal.x / width); //[I-S]LN=48;[I-E]
    myposzs = (int) Math.Floor(myposGlobal.z / width); //[I-S]LN=49;[I-E]
  } //[I-S]LN=50;[I-E]
 //[I-S]LN=51;[I-E]
  private void spawobjT() { //[I-S]LN=52;[I-E]
    if (myposxs == lastChuckX && myposzs == lastChuckZ) return; //[I-S]LN=53;[I-E]
    lastChuckX = myposxs; //[I-S]LN=54;[I-E]
    lastChuckZ = myposzs; //[I-S]LN=55;[I-E]
 //[I-S]LN=56;[I-E]
    startx = -chunks; //[I-S]LN=57;[I-E]
    startz = -chunks; //[I-S]LN=58;[I-E]
    endx = chunks; //[I-S]LN=59;[I-E]
    endz = chunks; //[I-S]LN=60;[I-E]
 //[I-S]LN=61;[I-E]
    gerax = startx; //[I-S]LN=62;[I-E]
    geraz = startz; //[I-S]LN=63;[I-E]
    gerado = true; //[I-S]LN=64;[I-E]
  } //[I-S]LN=65;[I-E]
 //[I-S]LN=66;[I-E]
  private void processotime(int timeDaley) { //[I-S]LN=67;[I-E]
    if (!gerado) return; //[I-S]LN=68;[I-E]
    int gerandor = 0; //[I-S]LN=69;[I-E]
    while (gerandor < timeDaley) { //[I-S]LN=70;[I-E]
      if (gerax >= endx) { //[I-S]LN=71;[I-E]
        gerax = startx; //[I-S]LN=72;[I-E]
        geraz++; //[I-S]LN=73;[I-E]
        if (geraz >= endz) { //[I-S]LN=74;[I-E]
          gerado = false; //[I-S]LN=75;[I-E]
          break; //[I-S]LN=76;[I-E]
        } //[I-S]LN=77;[I-E]
      } //[I-S]LN=78;[I-E]
      int px = gerax + myposxs; //[I-S]LN=79;[I-E]
      int pz = geraz + myposzs; //[I-S]LN=80;[I-E]
      long poskey = CodificKey(px, pz); //[I-S]LN=81;[I-E]
      if (!chunck.containsKey(poskey)) { //[I-S]LN=82;[I-E]
        SpatialObject TerrObj = object.TerrCriate(px * width, pz * width); //[I-S]LN=83;[I-E]
        if (TerrObj != null && TerrObj.exists()) chunck.put(poskey, TerrObj); //[I-S]LN=84;[I-E]
      } //[I-S]LN=85;[I-E]
      gerax++; //[I-S]LN=86;[I-E]
      gerandor++; //[I-S]LN=87;[I-E]
    } //[I-S]LN=88;[I-E]
  } //[I-S]LN=89;[I-E]
 //[I-S]LN=90;[I-E]
  private void removeChunck() { //[I-S]LN=91;[I-E]
    Iterator<Map.Entry<Long, SpatialObject>> item = chunck.entrySet().iterator(); //[I-S]LN=92;[I-E]
    while (item.hasNext()) { //[I-S]LN=93;[I-E]
      Map.Entry<Long, SpatialObject> entregrar = item.next(); //[I-S]LN=94;[I-E]
      int posChunckX = DescodificKeyX(entregrar.getKey()); //[I-S]LN=95;[I-E]
      int posChunckZ = DescodificKeyZ(entregrar.getKey()); //[I-S]LN=96;[I-E]
      int dX = Math.abs(posChunckX - myposxs); //[I-S]LN=97;[I-E]
      int dZ = Math.abs(posChunckZ - myposzs); //[I-S]LN=98;[I-E]
      if ((time += Math.bySecond()) > 3f && (dX > (chunks) || dZ > (chunks))) { //[I-S]LN=99;[I-E]
        entregrar.getValue().destroy(); //[I-S]LN=100;[I-E]
        item.remove(); //[I-S]LN=101;[I-E]
        time = 0; //[I-S]LN=102;[I-E]
      } //[I-S]LN=103;[I-E]
    } //[I-S]LN=104;[I-E]
  } //[I-S]LN=105;[I-E]
 //[I-S]LN=106;[I-E]
  public long CodificKey(int x, int z) { //[I-S]LN=107;[I-E]
    return (((long) x) << 32) | (z & 0xFFFFFFFFL); //[I-S]LN=108;[I-E]
  } //[I-S]LN=109;[I-E]
 //[I-S]LN=110;[I-E]
  public int DescodificKeyX(long x) { //[I-S]LN=111;[I-E]
    return (int) (x >> 32); //[I-S]LN=112;[I-E]
  } //[I-S]LN=113;[I-E]
 //[I-S]LN=114;[I-E]
  public int DescodificKeyZ(long z) { //[I-S]LN=115;[I-E]
    return (int) z; //[I-S]LN=116;[I-E]
  } //[I-S]LN=117;[I-E]
} //[I-S]LN=118;[I-E]