class chunkgen extends Component { //[I-S]LN=0;[I-E]
  public class object { //[I-S]LN=1;[I-E]
    public SpatialObject TerrCriate(float posx, float posy) { //[I-S]LN=2;[I-E]
      SpatialObject Obj = new SpatialObject("chuck "); //[I-S]LN=3;[I-E]
      Obj.setStatic(true); //[I-S]LN=4;[I-E]
      Obj.addComponent(new ModelRenderer()); //[I-S]LN=5;[I-E]
      Obj.addComponent(new TerreController()); //[I-S]LN=6;[I-E]
      Obj.setPosition(posx, 0, posy); //[I-S]LN=7;[I-E]
      Obj.removeComponent(new TerreController()); //[I-S]LN=8;[I-E]
      return Obj; //[I-S]LN=9;[I-E]
    } //[I-S]LN=10;[I-E]
  } //[I-S]LN=11;[I-E]
 //[I-S]LN=12;[I-E]
  @Hide public float waterlevel = .5f; //[I-S]LN=13;[I-E]
  @Hide public int chunks = 4, width = 16, seed; //[I-S]LN=14;[I-E]
  public float scale, heightscale, valuelog; //[I-S]LN=15;[I-E]
  public MaterialFile TerrMate, WaterMate; //[I-S]LN=16;[I-E]
  @Hide public chunkgen.object object; //[I-S]LN=17;[I-E]
  public ObjectFile[] trees = new ObjectFile[1]; //[I-S]LN=18;[I-E]
  private Vector3 myposGlobal; //[I-S]LN=19;[I-E]
  private int lastChuckX = Integer.MIN_VALUE, lastChuckZ = Integer.MIN_VALUE; //[I-S]LN=20;[I-E]
  private int myposxs, myposzs; //[I-S]LN=21;[I-E]
  public HashMap<Long, SpatialObject> chunck = new HashMap<Long, SpatialObject>(); //[I-S]LN=22;[I-E]
  public Queue<Long> process = new ArrayDeque<Long>(); //[I-S]LN=23;[I-E]
 //[I-S]LN=24;[I-E]
  @Override //[I-S]LN=25;[I-E]
  void start() { //[I-S]LN=26;[I-E]
    object = new chunkgen.object(); //[I-S]LN=27;[I-E]
    seed = Random.range(0, 500); //[I-S]LN=28;[I-E]
  } //[I-S]LN=29;[I-E]
 //[I-S]LN=30;[I-E]
  @Override //[I-S]LN=31;[I-E]
  void repeat() { //[I-S]LN=32;[I-E]
    posplayermy(); //[I-S]LN=33;[I-E]
    spawobjT(); //[I-S]LN=34;[I-E]
    processaChuck(1); //[I-S]LN=35;[I-E]
    removeChunck(); //[I-S]LN=36;[I-E]
  } //[I-S]LN=37;[I-E]
 //[I-S]LN=38;[I-E]
  private void posplayermy() { //[I-S]LN=39;[I-E]
    myposGlobal = myObject.getGlobalPosition(); //[I-S]LN=40;[I-E]
    myposxs = (int) Math.Floor(myposGlobal.x / width); //[I-S]LN=41;[I-E]
    myposzs = (int) Math.Floor(myposGlobal.z / width); //[I-S]LN=42;[I-E]
  } //[I-S]LN=43;[I-E]
 //[I-S]LN=44;[I-E]
  private void spawobjT() { //[I-S]LN=45;[I-E]
    if (myposxs == lastChuckX && myposzs == lastChuckZ) return; //[I-S]LN=46;[I-E]
    lastChuckX = myposxs; //[I-S]LN=47;[I-E]
    lastChuckZ = myposzs; //[I-S]LN=48;[I-E]
    for (int x = (-chunks); x < (chunks); x++) { //[I-S]LN=49;[I-E]
      for (int z = (-chunks); z < (chunks); z++) { //[I-S]LN=50;[I-E]
        int px = x + myposxs; //[I-S]LN=51;[I-E]
        int pz = z + myposzs; //[I-S]LN=52;[I-E]
        long poskey = CodificKey(px, pz); //[I-S]LN=53;[I-E]
        if (chunck.containsKey(poskey)) continue; //[I-S]LN=54;[I-E]
        process.add(poskey); //[I-S]LN=55;[I-E]
      } //[I-S]LN=56;[I-E]
    }  //[I-S]LN=57;[I-E]
  } //[I-S]LN=58;[I-E]
 //[I-S]LN=59;[I-E]
  private void processaChuck(int quant) { //[I-S]LN=60;[I-E]
    if (process.isEmpty()) return; //[I-S]LN=61;[I-E]
    for (int i = quant; i >0; i--) { //[I-S]LN=62;[I-E]
      long poss = process.remove(); //[I-S]LN=63;[I-E]
      int px = (int) DescodificKeyX(poss); //[I-S]LN=64;[I-E]
      int pz = (int) DescodificKeyZ(poss); //[I-S]LN=65;[I-E]
      long poskey = CodificKey(px, pz); //[I-S]LN=66;[I-E]
      if (chunck.containsKey(poskey)) continue; //[I-S]LN=67;[I-E]
      SpatialObject TerrObj = object.TerrCriate(px * width, pz * width); //[I-S]LN=68;[I-E]
      if (TerrObj != null && TerrObj.exists()) chunck.put(poskey, TerrObj); //[I-S]LN=69;[I-E]
    } //[I-S]LN=70;[I-E]
  } //[I-S]LN=71;[I-E]
 //[I-S]LN=72;[I-E]
  private void removeChunck() { //[I-S]LN=73;[I-E]
    Iterator<Map.Entry<Long, SpatialObject>> item = chunck.entrySet().iterator(); //[I-S]LN=74;[I-E]
    while (item.hasNext()) { //[I-S]LN=75;[I-E]
      Map.Entry<Long, SpatialObject> entregrar = item.next(); //[I-S]LN=76;[I-E]
      int posChunckX = DescodificKeyX(entregrar.getKey()); //[I-S]LN=77;[I-E]
      int posChunckZ = DescodificKeyZ(entregrar.getKey()); //[I-S]LN=78;[I-E]
      int dX = Math.abs(posChunckX - myposxs); //[I-S]LN=79;[I-E]
      int dZ = Math.abs(posChunckZ - myposzs); //[I-S]LN=80;[I-E]
      if (dX > (chunks) || dZ > (chunks)) { //[I-S]LN=81;[I-E]
        entregrar.getValue().destroy(); //[I-S]LN=82;[I-E]
        item.remove(); //[I-S]LN=83;[I-E]
      } //[I-S]LN=84;[I-E]
    } //[I-S]LN=85;[I-E]
  } //[I-S]LN=86;[I-E]
 //[I-S]LN=87;[I-E]
  public long CodificKey(int x, int z) { //[I-S]LN=88;[I-E]
    return (((long) x) << 32) | (z & 0xFFFFFFFFL); //[I-S]LN=89;[I-E]
  } //[I-S]LN=90;[I-E]
 //[I-S]LN=91;[I-E]
  public int DescodificKeyX(long x) { //[I-S]LN=92;[I-E]
    return (int) (x >> 32); //[I-S]LN=93;[I-E]
  } //[I-S]LN=94;[I-E]
 //[I-S]LN=95;[I-E]
  public int DescodificKeyZ(long z) { //[I-S]LN=96;[I-E]
    return (int) z; //[I-S]LN=97;[I-E]
  } //[I-S]LN=98;[I-E]
} //[I-S]LN=99;[I-E]