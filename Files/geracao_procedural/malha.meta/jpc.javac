class malha { //[I-S]LN=0;[I-E]
  private PerlinNoise perlin = new PerlinNoise(100); //[I-S]LN=1;[I-E]
 //[I-S]LN=2;[I-E]
  public void ChunckSimul(chunkSimul data) { //[I-S]LN=3;[I-E]
    data.VertecesCount += 1; //[I-S]LN=4;[I-E]
    data.NormalCount += 1; //[I-S]LN=5;[I-E]
    data.TrianCount += 6; //[I-S]LN=6;[I-E]
    data.UvMapCount += 1; //[I-S]LN=7;[I-E]
  } //[I-S]LN=8;[I-E]
 //[I-S]LN=9;[I-E]
  public void trianguloN(int value, IntBuffer triang) { //[I-S]LN=10;[I-E]
    int verts = 0; //[I-S]LN=11;[I-E]
    for (int z = 0; z < value; z++) { //[I-S]LN=12;[I-E]
      for (int x = 0; x < value; x++) { //[I-S]LN=13;[I-E]
        triang.put(verts + 0); //[I-S]LN=14;[I-E]
        triang.put(verts + value + 1); //[I-S]LN=15;[I-E]
        triang.put(verts + 1); //[I-S]LN=16;[I-E]
        triang.put(verts + 1); //[I-S]LN=17;[I-E]
        triang.put(verts + value + 1); //[I-S]LN=18;[I-E]
        triang.put(verts + value + 2); //[I-S]LN=19;[I-E]
        verts++; //[I-S]LN=20;[I-E]
      } //[I-S]LN=21;[I-E]
      verts++; //[I-S]LN=22;[I-E]
    } //[I-S]LN=23;[I-E]
  } //[I-S]LN=24;[I-E]
 //[I-S]LN=25;[I-E]
  public Vertex meshupN(boolean onoff, ModelRenderer model, MaterialFile mateFile, int[] trianglo, Vector3Buffer vertices, Vector3Buffer normal, Vector2Buffer uv) { //[I-S]LN=26;[I-E]
    Vertex vertexs = new Vertex(); //[I-S]LN=27;[I-E]
    vertexs.setVertices(vertices); //[I-S]LN=28;[I-E]
    vertexs.setNormals(normal); //[I-S]LN=29;[I-E]
    vertexs.setUVs(uv); //[I-S]LN=30;[I-E]
    vertexs.setTriangles(trianglo); //[I-S]LN=31;[I-E]
    vertexs.apply(); //[I-S]LN=32;[I-E]
 //[I-S]LN=33;[I-E]
    model.setMaterialFile(mateFile); //[I-S]LN=34;[I-E]
    model.setVertex(vertexs); //[I-S]LN=35;[I-E]
    if (onoff) model.material.setReceiveLight(false); //[I-S]LN=36;[I-E]
    model.setCastShadowEnabled(false); //[I-S]LN=37;[I-E]
    return vertexs; //[I-S]LN=38;[I-E]
  } //[I-S]LN=39;[I-E]
 //[I-S]LN=40;[I-E]
  public void generationlog(chunkgen tama, Vector3 mypos, SpatialObject obj, float x, float y, float z) { //[I-S]LN=41;[I-E]
    float worldx = x + mypos.x; //[I-S]LN=42;[I-E]
    float worldz = z + mypos.z; //[I-S]LN=43;[I-E]
    int chunkX = (int) obj.getGlobalPosition().x; //[I-S]LN=44;[I-E]
    int chunkZ = (int) obj.getGlobalPosition().z; //[I-S]LN=45;[I-E]
    if (worldx < chunkX || worldx >= chunkX + tama.width || worldx < chunkZ || worldz >= chunkZ + tama.width) return; //[I-S]LN=46;[I-E]
    int space = Random.range(3, 5); //[I-S]LN=47;[I-E]
    if (((int) worldx % space != 0) || ((int) worldz % space != 0)) return; //[I-S]LN=48;[I-E]
    float addspaw = perlin.noise(worldx + tama.seed, worldz + tama.seed); //[I-S]LN=49;[I-E]
    addspaw -= perlin.noise(worldx * 50f + tama.seed, worldz * 50f + tama.seed); //[I-S]LN=50;[I-E]
    if (addspaw >= tama.valuelog && y > tama.waterlevel + tama.heightscale) { //[I-S]LN=51;[I-E]
      int quemspaw = Random.range(0, tama.trees.length - 1); //[I-S]LN=52;[I-E]
      Vector3 positobj = new Vector3(worldx, y + mypos.y, worldz) - obj.getGlobalPosition(); //[I-S]LN=53;[I-E]
      SpatialObject log = obj.instantiate(tama.trees[quemspaw], positobj); //[I-S]LN=54;[I-E]
      log.setParent(obj); //[I-S]LN=55;[I-E]
    }  //[I-S]LN=56;[I-E]
  } //[I-S]LN=57;[I-E]
 //[I-S]LN=58;[I-E]
  public float perlinnoises(chunkgen tama, SpatialObject myObj, float x, float z) { //[I-S]LN=59;[I-E]
    float calcu = 0; //[I-S]LN=60;[I-E]
    float pi = 22f / 7f; //[I-S]LN=61;[I-E]
    float valuex = (x + tama.seed) + myObj.position.x; //[I-S]LN=62;[I-E]
    float valuez = (z + tama.seed) + myObj.position.z; //[I-S]LN=63;[I-E]
    calcu += perlin.noise(valuex, valuez) * tama.heightscale; //[I-S]LN=64;[I-E]
    calcu += perlin.noise(valuex * pi, valuez * pi) * tama.heightscale * 0.5f; //[I-S]LN=65;[I-E]
    calcu += perlin.noise(valuex / pi, valuez / pi) * tama.heightscale / 0.5f; //[I-S]LN=66;[I-E]
    calcu += perlin.noise(valuex - pi, valuez - pi) * tama.heightscale - 0.1f; //[I-S]LN=67;[I-E]
    return calcu; //[I-S]LN=68;[I-E]
  } //[I-S]LN=69;[I-E]
} //[I-S]LN=70;[I-E]